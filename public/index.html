<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="theme-color" content="#0a0a0a" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" sizes="16x16 32x32 48x48" />
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180x180.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/apple-touch-icon-167x167.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-touch-icon-120x120.png" />
    <title>LAN Video Server</title>
    <script src="https://unpkg.com/lucide@0.294.0/dist/umd/lucide.min.js"></script>
    <script src="/js/media-db.js?v=5"></script>
    <script src="/js/media-ai.js?v=5"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --sp-3: 3px;
        --sp-5: 5px;
        --sp-8: 8px;
        --sp-13: 13px;
        --sp-21: 21px;
        --sp-34: 34px;
        --sp-55: 55px;
        --sp-89: 89px;
        --black: #0a0a0a;
        --white: #fafafa;
        --gray-100: #f5f5f5;
        --gray-200: #e5e5e5;
        --gray-300: #d4d4d4;
        --gray-400: #a3a3a3;
        --gray-500: #737373;
        --gray-600: #525252;
        --gray-700: #404040;
        --gray-800: #262626;
        --gray-900: #171717;
        --accent: #ff3b30;
        --accent-hover: #ff453a;
        --success: #30d158;
        --text-xs: 11px;
        --text-sm: 13px;
        --text-base: 16px;
        --text-lg: 21px;
        --text-2xl: 34px;
        --safe-top: env(safe-area-inset-top, 0px);
        --safe-bottom: env(safe-area-inset-bottom, 0px);
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      body {
        font-family: "Inter", -apple-system, sans-serif;
        background: var(--black);
        color: var(--white);
        min-height: 100vh;
        min-height: 100dvh;
        line-height: 1.618;
        -webkit-font-smoothing: antialiased;
        overflow-x: hidden;
      }

      /* Mobile-first container */
      .container {
        max-width: 987px;
        margin: 0 auto;
        padding: var(--sp-21);
        padding-top: calc(var(--sp-21) + var(--safe-top));
        padding-bottom: calc(var(--sp-21) + var(--safe-bottom));
      }

      /* Header - compact on mobile */
      .header {
        display: flex;
        align-items: center;
        gap: var(--sp-13);
        margin-bottom: var(--sp-34);
        padding-bottom: var(--sp-13);
        border-bottom: 1px solid var(--gray-800);
      }
      .logo {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--accent);
        border-radius: 12px;
        flex-shrink: 0;
      }
      .logo i {
        width: 24px;
        height: 24px;
        color: var(--white);
      }
      .header-text h1 {
        font-size: var(--text-lg);
        font-weight: 600;
        letter-spacing: -0.02em;
      }
      .header-text p {
        font-size: var(--text-xs);
        color: var(--gray-400);
      }
      .header-text {
        flex: 1;
      }
      .header-btn {
        background: var(--gray-800);
        border: 1px solid var(--gray-700);
        border-radius: 12px;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--gray-400);
        cursor: pointer;
        position: relative;
        transition: all 0.15s;
      }
      .header-btn:hover {
        background: var(--gray-700);
        color: var(--white);
      }
      .header-btn i {
        width: 20px;
        height: 20px;
      }
      .downloads-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background: var(--accent);
        color: white;
        font-size: 10px;
        font-weight: 600;
        min-width: 18px;
        height: 18px;
        border-radius: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 5px;
      }

      /* Download Manager */
      .downloads-empty {
        text-align: center;
        padding: var(--sp-34);
        color: var(--gray-500);
      }
      .download-list {
        display: flex;
        flex-direction: column;
        gap: var(--sp-8);
      }
      .download-item {
        background: var(--gray-800);
        border: 1px solid var(--gray-700);
        border-radius: 12px;
        padding: var(--sp-13);
      }
      .download-item-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--sp-8);
      }
      .download-item-name {
        font-size: var(--text-sm);
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        margin-right: var(--sp-8);
      }
      .download-item-controls {
        display: flex;
        gap: var(--sp-5);
      }
      .download-ctrl-btn {
        background: var(--gray-700);
        border: none;
        border-radius: 6px;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--gray-400);
        cursor: pointer;
        transition: all 0.15s;
      }
      .download-ctrl-btn:hover {
        background: var(--gray-600);
        color: var(--white);
      }
      .download-ctrl-btn.danger:hover {
        background: var(--accent);
      }
      .download-ctrl-btn.play {
        background: var(--success);
        color: var(--white);
      }
      .download-ctrl-btn.play:hover {
        background: #22c55e;
      }
      .download-ctrl-btn i {
        width: 14px;
        height: 14px;
      }
      .download-item-progress {
        height: 4px;
        background: var(--gray-700);
        border-radius: 2px;
        overflow: hidden;
        margin-bottom: var(--sp-5);
      }
      .download-item-progress-fill {
        height: 100%;
        background: var(--success);
        border-radius: 2px;
        transition: width 0.3s;
      }
      .download-item-meta {
        display: flex;
        justify-content: space-between;
        font-size: var(--text-xs);
        color: var(--gray-400);
      }
      .download-item-speed {
        color: var(--success);
      }

      /* Downloads Section (main page) */
      .downloads-section {
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 16px;
        padding: var(--sp-13);
        margin-bottom: var(--sp-21);
      }
      .downloads-section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--sp-13);
      }
      .downloads-section-title {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        font-size: var(--text-sm);
        font-weight: 600;
        color: var(--gray-300);
      }
      .downloads-section-title i {
        width: 16px;
        height: 16px;
      }
      .downloads-section-count {
        background: var(--gray-800);
        padding: 2px 8px;
        border-radius: 10px;
        font-size: var(--text-xs);
        color: var(--gray-400);
      }
      .downloads-section-list {
        display: flex;
        flex-direction: column;
        gap: var(--sp-8);
        max-height: 300px;
        overflow-y: auto;
      }
      .downloads-section-empty {
        text-align: center;
        padding: var(--sp-13);
        color: var(--gray-600);
        font-size: var(--text-sm);
      }
      .dl-item {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        padding: var(--sp-8);
        background: var(--gray-800);
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.15s;
      }
      .dl-item:hover {
        background: var(--gray-700);
      }
      .dl-item-info {
        flex: 1;
        min-width: 0;
      }
      .dl-item-name {
        font-size: var(--text-sm);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .dl-item-meta {
        font-size: var(--text-xs);
        color: var(--gray-500);
        display: flex;
        gap: var(--sp-8);
      }
      .dl-item-progress {
        width: 60px;
        height: 4px;
        background: var(--gray-700);
        border-radius: 2px;
        overflow: hidden;
      }
      .dl-item-progress-fill {
        height: 100%;
        background: var(--success);
        transition: width 0.3s;
      }
      .dl-item-progress-fill.downloading {
        background: var(--accent);
      }
      .dl-item-actions {
        display: flex;
        gap: var(--sp-5);
      }
      .dl-item-btn {
        background: transparent;
        border: none;
        color: var(--gray-500);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .dl-item-btn:hover {
        background: var(--gray-600);
        color: var(--white);
      }
      .dl-item-btn.play {
        color: var(--success);
      }
      .dl-item-btn i {
        width: 16px;
        height: 16px;
      }

      /* TV Status - mobile optimized */
      .tv-card {
        display: flex;
        align-items: center;
        gap: var(--sp-13);
        padding: var(--sp-13);
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 12px;
        margin-bottom: var(--sp-21);
      }
      .tv-icon {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--gray-800);
        border-radius: 10px;
        flex-shrink: 0;
      }
      .tv-icon i {
        width: 20px;
        height: 20px;
      }
      .tv-info {
        flex: 1;
        min-width: 0;
      }
      .tv-info h3 {
        font-size: var(--text-sm);
        font-weight: 500;
      }
      .tv-info p {
        font-size: var(--text-xs);
        color: var(--gray-400);
      }
      .tv-info a {
        color: var(--accent);
        text-decoration: none;
      }
      .tv-count {
        font-size: var(--text-2xl);
        font-weight: 700;
        color: var(--success);
        min-width: 44px;
        text-align: center;
      }
      .tv-count.zero {
        color: var(--gray-600);
      }

      /* Main input - touch friendly */
      .main-input {
        position: relative;
        margin-bottom: var(--sp-13);
      }
      .main-input input {
        width: 100%;
        padding: var(--sp-13) var(--sp-13) var(--sp-13) 44px;
        font-size: var(--text-base);
        font-family: inherit;
        background: var(--gray-900);
        border: 2px solid var(--gray-700);
        border-radius: 12px;
        color: var(--white);
        transition: all 0.2s;
      }
      .main-input input:focus {
        outline: none;
        border-color: var(--accent);
      }
      .main-input input::placeholder {
        color: var(--gray-600);
      }
      .main-input .input-icon {
        position: absolute;
        left: var(--sp-13);
        top: 50%;
        transform: translateY(-50%);
        color: var(--gray-500);
      }
      .main-input .input-icon i {
        width: 18px;
        height: 18px;
      }

      /* Detection hint */
      .detect-hint {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        padding: var(--sp-8) var(--sp-13);
        background: var(--gray-800);
        border-radius: 8px;
        font-size: var(--text-xs);
        color: var(--gray-400);
        margin-bottom: var(--sp-13);
        min-height: 32px;
      }
      .detect-hint i {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
      }
      .detect-hint.ready {
        color: var(--success);
      }
      .detect-hint .site-badge {
        background: var(--gray-700);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      /* Action button - big touch target */
      .send-btn {
        width: 100%;
        padding: var(--sp-13);
        font-size: var(--text-base);
        font-weight: 600;
        font-family: inherit;
        background: var(--accent);
        color: var(--white);
        border: none;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.15s;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--sp-8);
        min-height: 48px;
      }
      .send-btn:hover {
        background: var(--accent-hover);
      }
      .send-btn:active {
        transform: scale(0.98);
      }
      .send-btn:disabled {
        background: var(--gray-700);
        cursor: not-allowed;
      }
      .send-btn i {
        width: 18px;
        height: 18px;
      }

      /* Secondary actions - scrollable row on mobile */
      .secondary-actions {
        display: flex;
        gap: var(--sp-8);
        margin-top: var(--sp-13);
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding-bottom: var(--sp-5);
      }
      .secondary-actions::-webkit-scrollbar {
        display: none;
      }
      .sec-btn {
        flex-shrink: 0;
        padding: var(--sp-8) var(--sp-13);
        font-size: var(--text-xs);
        font-family: inherit;
        background: var(--gray-800);
        color: var(--gray-300);
        border: 1px solid var(--gray-700);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: var(--sp-5);
        white-space: nowrap;
      }
      .sec-btn:hover, .sec-btn:active {
        color: var(--white);
        background: var(--gray-700);
      }
      .sec-btn i {
        width: 14px;
        height: 14px;
      }

      /* Remote Control - the star of the show */
      .remote-control {
        margin-top: var(--sp-21);
        padding: var(--sp-21);
        background: linear-gradient(180deg, var(--gray-900) 0%, var(--black) 100%);
        border: 1px solid var(--gray-800);
        border-radius: 16px;
      }
      .remote-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--sp-13);
        gap: var(--sp-8);
      }
      .remote-title {
        font-size: var(--text-xs);
        color: var(--gray-500);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .remote-media {
        font-size: var(--text-sm);
        color: var(--gray-300);
        flex: 1;
        text-align: right;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Progress bar - chunky for touch */
      .remote-progress {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        margin-bottom: var(--sp-21);
      }
      .remote-time {
        font-size: var(--text-xs);
        color: var(--gray-400);
        font-variant-numeric: tabular-nums;
        min-width: 40px;
      }
      .remote-time:last-child {
        text-align: right;
      }
      .remote-seek {
        flex: 1;
        height: 8px;
        background: var(--gray-700);
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .remote-seek-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background: var(--accent);
        width: 0%;
        border-radius: 4px;
        transition: width 0.1s;
      }
      .remote-seek:active .remote-seek-fill {
        background: var(--white);
      }

      /* Swipe gesture zone */
      .swipe-zone {
        position: relative;
        height: 120px;
        background: var(--gray-800);
        border-radius: 16px;
        margin-bottom: var(--sp-13);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        touch-action: pan-x;
        user-select: none;
        cursor: grab;
      }
      .swipe-zone:active {
        cursor: grabbing;
      }
      .swipe-zone-hint {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--sp-5);
        color: var(--gray-500);
        pointer-events: none;
        transition: opacity 0.2s;
      }
      .swipe-zone-hint i {
        width: 32px;
        height: 32px;
      }
      .swipe-zone-hint span {
        font-size: var(--text-xs);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .swipe-zone.swiping .swipe-zone-hint {
        opacity: 0.3;
      }
      .swipe-feedback {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: 700;
        color: var(--white);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s;
      }
      .swipe-zone.swiping .swipe-feedback {
        opacity: 1;
      }
      .swipe-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 0;
        background: var(--accent);
        opacity: 0.3;
        pointer-events: none;
        transition: width 0.05s;
      }
      .swipe-indicator.left {
        right: 50%;
      }
      .swipe-indicator.right {
        left: 50%;
      }

      /* Remote buttons - big, beautiful, touch-optimized */
      .remote-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr 1.5fr 1fr 1fr;
        gap: var(--sp-8);
      }
      .remote-btn {
        padding: var(--sp-13);
        font-size: var(--text-sm);
        font-family: inherit;
        background: var(--gray-800);
        color: var(--gray-300);
        border: none;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--sp-3);
        min-height: 48px;
      }
      .remote-btn:hover {
        color: var(--white);
        background: var(--gray-700);
      }
      .remote-btn:active {
        transform: scale(0.95);
        background: var(--accent);
        color: var(--white);
      }
      .remote-btn i {
        width: 20px;
        height: 20px;
      }
      .remote-btn span {
        font-size: var(--text-xs);
        font-weight: 600;
      }
      .remote-play {
        background: var(--accent);
        color: var(--white);
      }
      .remote-play:hover {
        background: var(--accent-hover);
      }
      .remote-play i {
        width: 28px;
        height: 28px;
      }

      /* Episode Panel in Remote */
      .episode-section {
        margin-top: var(--sp-21);
        padding-top: var(--sp-21);
        border-top: 1px solid var(--gray-800);
        display: none;
      }
      .episode-section.active {
        display: block;
      }
      .episode-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--sp-13);
      }
      .episode-label {
        font-size: var(--text-xs);
        color: var(--gray-500);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .episode-count {
        font-size: var(--text-xs);
        color: var(--gray-400);
        background: var(--gray-800);
        padding: 2px 8px;
        border-radius: 4px;
      }
      .episode-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: var(--sp-8);
        max-height: 200px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-right: var(--sp-5);
      }
      .episode-grid::-webkit-scrollbar {
        width: 4px;
      }
      .episode-grid::-webkit-scrollbar-track {
        background: var(--gray-800);
        border-radius: 2px;
      }
      .episode-grid::-webkit-scrollbar-thumb {
        background: var(--gray-600);
        border-radius: 2px;
      }
      .episode-btn {
        padding: var(--sp-8) var(--sp-13);
        font-size: var(--text-xs);
        font-family: inherit;
        background: var(--gray-800);
        color: var(--gray-300);
        border: 1px solid var(--gray-700);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
        text-align: left;
        overflow: hidden;
      }
      .episode-btn:hover {
        border-color: var(--gray-600);
        color: var(--white);
      }
      .episode-btn:active {
        transform: scale(0.98);
      }
      .episode-btn.active {
        border-color: var(--accent);
        background: var(--gray-700);
        color: var(--white);
      }
      .episode-btn-title {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 2px;
      }
      .episode-btn-meta {
        font-size: 10px;
        color: var(--gray-500);
      }

      /* Status */
      .status {
        margin-top: var(--sp-13);
        padding: var(--sp-13);
        background: var(--gray-900);
        border-left: 3px solid var(--gray-700);
        border-radius: 0 8px 8px 0;
        font-size: var(--text-sm);
        color: var(--gray-400);
      }
      .status.success {
        border-color: var(--success);
        color: var(--success);
      }
      .status.error {
        border-color: var(--accent);
        color: var(--accent);
      }

      /* Preview - collapsed by default on mobile */
      .preview {
        margin-top: var(--sp-21);
      }
      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--sp-8);
        cursor: pointer;
      }
      .preview-title {
        font-size: var(--text-xs);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--gray-400);
        display: flex;
        align-items: center;
        gap: var(--sp-5);
      }
      .preview-title i {
        width: 14px;
        height: 14px;
        transition: transform 0.2s;
      }
      .preview.collapsed .preview-title i {
        transform: rotate(-90deg);
      }
      .preview-container {
        aspect-ratio: 16/9;
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      .preview.collapsed .preview-container {
        display: none;
      }
      .preview-container video,
      .preview-container iframe,
      .preview-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 12px;
      }
      .preview-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--sp-8);
        color: var(--gray-600);
      }
      .preview-placeholder i {
        width: var(--sp-34);
        height: var(--sp-34);
      }

      /* AI Dashboard */
      .ai-dashboard {
        margin-top: var(--sp-21);
        display: flex;
        flex-direction: column;
        gap: var(--sp-13);
      }
      .ai-section {
        padding: var(--sp-13);
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 12px;
      }
      .ai-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--sp-8);
      }
      .ai-section-title {
        font-size: var(--text-xs);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-400);
        display: flex;
        align-items: center;
        gap: var(--sp-5);
      }
      .ai-section-title i {
        width: 14px;
        height: 14px;
      }
      .ai-section-content {
        display: flex;
        flex-direction: column;
        gap: var(--sp-8);
      }
      .ai-continue-item {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        padding: var(--sp-8);
        background: var(--gray-800);
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.15s;
      }
      .ai-continue-item:hover {
        background: var(--gray-700);
      }
      .ai-continue-thumb {
        width: 60px;
        height: 34px;
        background: var(--gray-700);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        position: relative;
        overflow: hidden;
      }
      .ai-continue-thumb i {
        width: 16px;
        height: 16px;
        color: var(--gray-500);
      }
      .ai-continue-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 3px;
        background: var(--accent);
      }
      .ai-continue-info {
        flex: 1;
        min-width: 0;
      }
      .ai-continue-title {
        font-size: var(--text-sm);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .ai-continue-meta {
        font-size: var(--text-xs);
        color: var(--gray-500);
      }
      .ai-network {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--sp-8) var(--sp-13);
      }
      .ai-network-info {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        font-size: var(--text-sm);
      }
      .ai-network-info i {
        width: 16px;
        height: 16px;
        color: var(--success);
      }
      .ai-network-detail {
        font-size: var(--text-xs);
        color: var(--gray-500);
      }
      .ai-storage {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--sp-8) var(--sp-13);
      }
      .ai-storage-info {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        font-size: var(--text-sm);
      }
      .ai-storage-info i {
        width: 16px;
        height: 16px;
        color: var(--gray-400);
      }
      .ai-cleanup-btn {
        display: flex;
        align-items: center;
        gap: var(--sp-5);
        padding: var(--sp-5) var(--sp-8);
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: var(--text-xs);
        cursor: pointer;
      }
      .ai-cleanup-btn i {
        width: 12px;
        height: 12px;
      }
      .ai-quality-badge, .ai-health-badge, .ai-smart-badge {
        display: inline-block;
        padding: 2px 6px;
        background: var(--success);
        color: white;
        border-radius: 4px;
        font-size: 10px;
        font-weight: 600;
      }
      .ai-health-badge {
        font-size: 9px;
      }
      .ai-smart-badge {
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        font-size: 8px;
      }
      .search-result.has-alternatives {
        border-left: 3px solid #8b5cf6;
      }

      /* History - minimal on mobile */
      .history {
        margin-top: var(--sp-21);
      }
      .history-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--sp-8);
      }
      .history-title {
        font-size: var(--text-xs);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--gray-400);
      }
      .history-clear {
        font-size: var(--text-xs);
        color: var(--gray-600);
        background: none;
        border: none;
        cursor: pointer;
        padding: var(--sp-5);
      }
      .history-list {
        display: flex;
        flex-direction: column;
        gap: var(--sp-5);
      }
      .history-item {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        padding: var(--sp-8) var(--sp-13);
        background: var(--gray-900);
        border: 1px solid transparent;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s;
      }
      .history-item:hover, .history-item:active {
        border-color: var(--gray-700);
        background: var(--gray-800);
      }
      .history-item i {
        width: 14px;
        height: 14px;
        color: var(--gray-500);
        flex-shrink: 0;
      }
      .history-item .title {
        flex: 1;
        font-size: var(--text-sm);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .history-item .site {
        font-size: 10px;
        color: var(--gray-600);
        text-transform: uppercase;
      }
      .history-item .delete {
        opacity: 0;
        color: var(--gray-600);
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px;
      }
      .history-item:hover .delete {
        opacity: 1;
      }

      /* Drop zone */
      .drop-zone {
        position: fixed;
        inset: 0;
        background: rgba(10, 10, 10, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .drop-zone.active {
        display: flex;
      }
      .drop-zone-inner {
        border: 2px dashed var(--gray-600);
        padding: var(--sp-55);
        text-align: center;
        border-radius: 16px;
        margin: var(--sp-21);
      }
      .drop-zone-inner i {
        width: var(--sp-55);
        height: var(--sp-55);
        color: var(--gray-400);
        margin-bottom: var(--sp-21);
      }

      /* Search Modal - fullscreen on mobile */
      .modal {
        position: fixed;
        inset: 0;
        background: var(--black);
        display: none;
        flex-direction: column;
        z-index: 1000;
      }
      .modal.active {
        display: flex;
      }
      .modal-header {
        padding: var(--sp-13);
        padding-top: calc(var(--sp-13) + var(--safe-top));
        border-bottom: 1px solid var(--gray-800);
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        background: var(--gray-900);
      }
      .modal-header input {
        flex: 1;
        padding: var(--sp-8) var(--sp-13);
        background: var(--gray-800);
        border: 1px solid var(--gray-700);
        border-radius: 8px;
        color: var(--white);
        font-family: inherit;
        font-size: var(--text-base);
      }
      .modal-header input:focus {
        outline: none;
        border-color: var(--accent);
      }
      .modal-header .close-btn {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--gray-800);
        border: none;
        border-radius: 8px;
        color: var(--gray-400);
        cursor: pointer;
        flex-shrink: 0;
      }
      .modal-tabs {
        display: flex;
        padding: var(--sp-8);
        gap: var(--sp-5);
        border-bottom: 1px solid var(--gray-800);
        background: var(--gray-900);
        overflow-x: auto;
      }
      .modal-tab {
        padding: var(--sp-8) var(--sp-13);
        background: transparent;
        border: none;
        border-radius: 6px;
        color: var(--gray-400);
        cursor: pointer;
        font-family: inherit;
        font-size: var(--text-sm);
        white-space: nowrap;
      }
      .modal-tab.active {
        color: var(--white);
        background: var(--gray-700);
      }
      .modal-body {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: var(--sp-13);
        padding-bottom: calc(var(--sp-13) + var(--safe-bottom));
      }
      .modal-footer {
        display: flex;
        gap: var(--sp-8);
        padding: var(--sp-13);
        border-top: 1px solid var(--gray-800);
      }
      .btn-secondary {
        flex: 1;
        padding: var(--sp-8) var(--sp-13);
        background: var(--gray-800);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
      }
      .btn-primary {
        flex: 2;
        padding: var(--sp-8) var(--sp-13);
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
      }
      .torrent-file-list {
        display: flex;
        flex-direction: column;
        gap: var(--sp-5);
      }
      .torrent-file-item {
        display: flex;
        align-items: center;
        gap: var(--sp-8);
        padding: var(--sp-8);
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 8px;
        cursor: pointer;
      }
      .torrent-file-item.selected {
        border-color: var(--accent);
        background: rgba(255, 59, 48, 0.1);
      }
      .torrent-file-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: var(--accent);
      }
      .torrent-file-info {
        flex: 1;
        min-width: 0;
      }
      .torrent-file-name {
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .torrent-file-size {
        font-size: 11px;
        color: var(--gray-500);
      }
      .torrent-loading {
        text-align: center;
        padding: var(--sp-21);
        color: var(--gray-500);
      }
      .search-results {
        display: flex;
        flex-direction: column;
        gap: var(--sp-8);
      }
      .search-result {
        display: flex;
        gap: var(--sp-8);
        padding: var(--sp-8);
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.15s;
      }
      .search-result:active {
        background: var(--gray-800);
        border-color: var(--gray-700);
      }
      .search-result-thumb {
        width: 120px;
        height: 68px;
        background: var(--gray-800);
        border-radius: 8px;
        flex-shrink: 0;
        overflow: hidden;
      }
      .search-result-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .search-result-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: var(--sp-3);
      }
      .search-result-title {
        font-size: var(--text-sm);
        font-weight: 500;
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      .search-result-meta {
        font-size: var(--text-xs);
        color: var(--gray-400);
      }
      .torrent-picker-btn {
        background: var(--gray-800);
        border: 1px solid var(--gray-700);
        border-radius: 8px;
        padding: 8px;
        color: var(--gray-400);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: all 0.15s;
      }
      .torrent-picker-btn:hover {
        background: var(--gray-700);
        color: var(--white);
        border-color: var(--gray-600);
      }
      .torrent-picker-btn i {
        width: 18px;
        height: 18px;
      }
      .search-loading, .search-empty {
        text-align: center;
        padding: var(--sp-34);
        color: var(--gray-500);
      }

      /* Bookmarklet - hidden on mobile by default */
      .bookmarklet {
        margin-top: var(--sp-34);
        padding: var(--sp-13);
        background: var(--gray-900);
        border: 1px solid var(--gray-800);
        border-radius: 12px;
      }
      .bookmarklet-title {
        font-size: var(--text-xs);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--gray-400);
        margin-bottom: var(--sp-5);
      }
      .bookmarklet-link {
        display: inline-block;
        padding: var(--sp-5) var(--sp-8);
        background: var(--gray-800);
        color: var(--white);
        text-decoration: none;
        font-size: var(--text-xs);
        border: 1px dashed var(--gray-600);
        border-radius: 6px;
      }
      .bookmarklet-hint {
        font-size: 10px;
        color: var(--gray-600);
        margin-top: var(--sp-5);
      }

      /* Footer */
      .footer {
        margin-top: var(--sp-55);
        padding-top: var(--sp-13);
        border-top: 1px solid var(--gray-800);
        display: flex;
        justify-content: space-between;
        font-size: var(--text-xs);
        color: var(--gray-600);
      }

      /* Desktop optimizations */
      @media (min-width: 768px) {
        .container {
          padding: var(--sp-34);
        }
        .header {
          gap: var(--sp-21);
          margin-bottom: var(--sp-55);
          padding-bottom: var(--sp-21);
        }
        .logo {
          width: var(--sp-55);
          height: var(--sp-55);
        }
        .logo i {
          width: var(--sp-34);
          height: var(--sp-34);
        }
        .header-text h1 {
          font-size: var(--text-2xl);
        }
        .header-text p {
          font-size: var(--text-sm);
        }
        .tv-card {
          padding: var(--sp-21);
          margin-bottom: var(--sp-34);
        }
        .tv-icon {
          width: var(--sp-55);
          height: var(--sp-55);
        }
        .tv-info h3 {
          font-size: var(--text-base);
        }
        .main-input input {
          padding: var(--sp-21) var(--sp-21) var(--sp-21) var(--sp-55);
          font-size: var(--text-lg);
        }
        .main-input .input-icon {
          left: var(--sp-21);
        }
        .main-input .input-icon i {
          width: var(--sp-21);
          height: var(--sp-21);
        }
        .send-btn {
          padding: var(--sp-21);
        }
        .sec-btn {
          flex: 1;
          padding: var(--sp-13);
          font-size: var(--text-sm);
        }
        .remote-buttons {
          gap: var(--sp-13);
        }
        .episode-grid {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
          max-height: 250px;
        }
        .modal {
          background: rgba(10, 10, 10, 0.95);
          align-items: center;
          justify-content: center;
          padding: var(--sp-21);
        }
        .modal-content {
          background: var(--gray-900);
          border: 1px solid var(--gray-700);
          border-radius: 16px;
          max-width: 800px;
          width: 100%;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
        .modal-header {
          padding: var(--sp-21);
          border-radius: 16px 16px 0 0;
        }
        .search-result-thumb {
          width: 144px;
          height: 81px;
        }
      }

      /* Small mobile optimizations */
      @media (max-width: 380px) {
        .remote-buttons {
          grid-template-columns: repeat(5, 1fr);
        }
        .remote-btn span {
          display: none;
        }
        .episode-grid {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="drop-zone" id="dropZone">
      <div class="drop-zone-inner">
        <i data-lucide="download"></i>
        <p>Drop .torrent file here</p>
      </div>
    </div>

    <!-- Torrent File Picker Modal -->
    <div class="modal" id="torrentPickerModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="torrentPickerTitle">Select files to download</h3>
          <button class="close-btn" id="closeTorrentPicker"><i data-lucide="x"></i></button>
        </div>
        <div class="modal-body" id="torrentPickerBody">
          <div class="torrent-loading">Loading torrent info...</div>
        </div>
        <div class="modal-footer">
          <button class="btn-secondary" id="torrentSelectAll">Select All</button>
          <button class="btn-primary" id="torrentStartDownload">Download Selected</button>
        </div>
      </div>
    </div>

    <!-- Download Manager Modal -->
    <div class="modal" id="downloadManagerModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Downloads</h3>
          <button class="close-btn" id="closeDownloadManager"><i data-lucide="x"></i></button>
        </div>
        <div class="modal-body" id="downloadManagerBody">
          <div class="downloads-empty">No active downloads</div>
        </div>
      </div>
    </div>

    <!-- Search Modal -->
    <div class="modal" id="searchModal">
      <div class="modal-content">
        <div class="modal-header">
          <input type="text" id="searchInput" placeholder="Search videos..." autocomplete="off" />
          <button class="close-btn" id="closeSearch"><i data-lucide="x"></i></button>
        </div>
        <div class="modal-tabs">
          <button class="modal-tab active" data-source="youtube">YouTube</button>
          <button class="modal-tab" data-source="torrents">Torrents</button>
        </div>
        <div class="modal-body">
          <div id="searchResultsContainer">
            <div class="search-empty">Enter a search query</div>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <header class="header">
        <div class="logo"><i data-lucide="play"></i></div>
        <div class="header-text">
          <h1>LAN Video</h1>
          <p>Any URL to TV</p>
        </div>
        <button class="header-btn" id="downloadsBtn" title="Downloads">
          <i data-lucide="download"></i>
          <span class="downloads-badge" id="downloadsBadge" style="display:none;">0</span>
        </button>
      </header>

      <!-- TV Status -->
      <div class="tv-card">
        <div class="tv-icon"><i data-lucide="tv"></i></div>
        <div class="tv-info">
          <h3>Television</h3>
          <p>Open <a href="/tv.html" id="tvLink">/tv.html</a> on TV</p>
        </div>
        <div class="tv-count zero" id="tvCount">0</div>
      </div>

      <!-- Main Input -->
      <div class="main-input">
        <span class="input-icon"><i data-lucide="link" id="inputIcon"></i></span>
        <input type="text" id="url" placeholder="Paste any video URL..." autocomplete="off" />
      </div>

      <!-- Detection hint -->
      <div class="detect-hint" id="detectHint">
        <i data-lucide="info"></i>
        <span id="detectText">Paste URL to detect type</span>
      </div>

      <!-- Send button -->
      <button class="send-btn" id="sendBtn" disabled>
        <i data-lucide="send"></i>
        <span>Send to TV</span>
      </button>

      <!-- Secondary actions -->
      <div class="secondary-actions">
        <button class="sec-btn" id="searchBtn"><i data-lucide="search"></i> Search</button>
        <button class="sec-btn" id="playHereBtn"><i data-lucide="play"></i> Play here</button>
        <button class="sec-btn" id="copyLinkBtn"><i data-lucide="link"></i> Copy</button>
        <button class="sec-btn" id="clearTvBtn"><i data-lucide="x"></i> Clear TV</button>
      </div>

      <!-- Remote Control -->
      <div class="remote-control" id="remoteControl">
        <div class="remote-header">
          <div class="remote-title">TV Remote</div>
          <div class="remote-media" id="remoteMedia">Nothing playing</div>
        </div>
        <div class="remote-progress">
          <span class="remote-time" id="remoteCurrentTime">00:00</span>
          <div class="remote-seek" id="remoteSeek">
            <div class="remote-seek-fill" id="remoteSeekFill"></div>
          </div>
          <span class="remote-time" id="remoteDuration">00:00</span>
        </div>
        <!-- Swipe Zone for gesture seeking -->
        <div class="swipe-zone" id="swipeZone">
          <div class="swipe-indicator left" id="swipeIndicatorLeft"></div>
          <div class="swipe-indicator right" id="swipeIndicatorRight"></div>
          <div class="swipe-zone-hint">
            <i data-lucide="move-horizontal"></i>
            <span>Swipe to seek</span>
          </div>
          <div class="swipe-feedback" id="swipeFeedback">+0s</div>
        </div>

        <div class="remote-buttons">
          <button class="remote-btn" id="remoteBack30" title="-30s">
            <i data-lucide="rewind"></i><span>30</span>
          </button>
          <button class="remote-btn" id="remoteBack10" title="-10s">
            <i data-lucide="skip-back"></i>
          </button>
          <button class="remote-btn remote-play" id="remotePlayPause" title="Play/Pause">
            <i data-lucide="play" id="remotePlayIcon"></i>
          </button>
          <button class="remote-btn" id="remoteForward10" title="+10s">
            <i data-lucide="skip-forward"></i>
          </button>
          <button class="remote-btn" id="remoteForward30" title="+30s">
            <span>30</span><i data-lucide="fast-forward"></i>
          </button>
        </div>

        <!-- Episode Section -->
        <div class="episode-section" id="episodeSection">
          <div class="episode-header">
            <span class="episode-label">Episodes</span>
            <span class="episode-count" id="episodeCount">0 episodes</span>
          </div>
          <div class="episode-grid" id="episodeGrid"></div>
        </div>
      </div>

      <!-- Status -->
      <div class="status" id="status">Ready</div>

      <!-- Preview -->
      <div class="preview collapsed" id="previewSection">
        <div class="preview-header" id="previewToggle">
          <span class="preview-title"><i data-lucide="chevron-down"></i> Preview</span>
        </div>
        <div class="preview-container" id="preview">
          <div class="preview-placeholder">
            <i data-lucide="film"></i>
            <span>No media</span>
          </div>
        </div>
      </div>

      <!-- Downloads Section (always visible) -->
      <div class="downloads-section" id="downloadsSection">
        <div class="downloads-section-header">
          <span class="downloads-section-title"><i data-lucide="download"></i> Downloads</span>
          <span class="downloads-section-count" id="downloadsCount">0</span>
        </div>
        <div class="downloads-section-list" id="downloadsSectionList">
          <div class="downloads-section-empty">No downloads</div>
        </div>
      </div>

      <!-- AI Dashboard -->
      <div class="ai-dashboard" id="aiDashboard">
        <!-- Continue Watching -->
        <div class="ai-section" id="continueSection" style="display:none;">
          <div class="ai-section-header">
            <span class="ai-section-title"><i data-lucide="play-circle"></i> Continue Watching</span>
          </div>
          <div class="ai-section-content" id="continueList"></div>
        </div>

        <!-- Network Status -->
        <div class="ai-section ai-network" id="networkSection">
          <div class="ai-network-info">
            <i data-lucide="wifi"></i>
            <span id="networkQuality">Checking...</span>
          </div>
          <div class="ai-network-detail" id="networkDetail"></div>
        </div>

        <!-- Storage -->
        <div class="ai-section ai-storage" id="storageSection">
          <div class="ai-storage-info">
            <i data-lucide="hard-drive"></i>
            <span>Storage: <span id="storageUsed">...</span></span>
          </div>
          <button class="ai-cleanup-btn" id="cleanupBtn" style="display:none;">
            <i data-lucide="trash-2"></i> Clean <span id="cleanupSize"></span>
          </button>
        </div>
      </div>

      <!-- History -->
      <div class="history" id="historySection">
        <div class="history-header">
          <span class="history-title">Recent</span>
          <button class="history-clear" id="clearHistory">Clear</button>
        </div>
        <div class="history-list" id="historyList"></div>
      </div>

      <!-- Bookmarklet -->
      <div class="bookmarklet">
        <div class="bookmarklet-title">Bookmarklet</div>
        <a class="bookmarklet-link" id="bookmarklet" href="#">Send to TV</a>
        <div class="bookmarklet-hint">Drag to bookmarks bar</div>
      </div>

      <footer class="footer">
        <span>LAN Video Server</span>
        <span id="serverInfo"></span>
      </footer>
    </div>

    <script>
      lucide.createIcons();

      const $ = (id) => document.getElementById(id);
      const urlInput = $("url");
      const sendBtn = $("sendBtn");
      const detectHint = $("detectHint");
      const detectText = $("detectText");
      const inputIcon = $("inputIcon");
      const status = $("status");
      const preview = $("preview");
      const tvCount = $("tvCount");
      const historyList = $("historyList");
      const dropZone = $("dropZone");
      const searchModal = $("searchModal");
      const searchInput = $("searchInput");
      const searchResultsContainer = $("searchResultsContainer");
      const episodeSection = $("episodeSection");
      const episodeGrid = $("episodeGrid");
      const episodeCount = $("episodeCount");

      // Server info
      $("serverInfo").textContent = location.host;
      $("tvLink").href = `http://${location.host}/tv.html`;

      // Preview toggle
      $("previewToggle").addEventListener("click", () => {
        $("previewSection").classList.toggle("collapsed");
        lucide.createIcons();
      });

      // Bookmarklet
      const bookmarkletCode = `javascript:(function(){var s=document.location.href;fetch('http://${location.host}/api/url2hls',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:s})}).then(r=>r.json()).then(d=>{if(d.streamUrl){fetch('http://${location.host}/tv/push',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:d.streamUrl})}).then(()=>alert('Sent to TV: '+d.name)).catch(e=>alert('Error: '+e))}else{fetch('http://${location.host}/tv/push',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:s})}).then(()=>alert('Sent to TV')).catch(e=>alert('Error: '+e))}}).catch(()=>{fetch('http://${location.host}/tv/push',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:s})}).then(()=>alert('Sent to TV'))})})();`;
      $("bookmarklet").href = bookmarkletCode;

      // Episode state
      let currentEpisodes = null;
      let currentStreamId = null;
      let currentMagnetURI = null;
      let currentEpisodeIndex = 0;

      // History management
      function getHistory() {
        try { return JSON.parse(localStorage.getItem("lanvideo_history") || "[]"); } catch { return []; }
      }
      function saveHistory(items) {
        localStorage.setItem("lanvideo_history", JSON.stringify(items.slice(0, 15)));
      }
      function addToHistory(url, title, site, icon) {
        const history = getHistory().filter((h) => h.url !== url);
        history.unshift({ url, title: title || url, site: site || "", icon: icon || "link", time: Date.now() });
        saveHistory(history);
        renderHistory();
      }
      function renderHistory() {
        const history = getHistory();
        if (history.length === 0) {
          $("historySection").style.display = "none";
          return;
        }
        $("historySection").style.display = "block";
        historyList.innerHTML = history.map((h, i) => `
          <div class="history-item" data-url="${encodeURIComponent(h.url)}">
            <i data-lucide="${h.icon || "link"}"></i>
            <span class="title">${h.title}</span>
            ${h.site ? `<span class="site">${h.site}</span>` : ""}
            <button class="delete" data-idx="${i}"><i data-lucide="x"></i></button>
          </div>
        `).join("");
        lucide.createIcons();

        historyList.querySelectorAll(".history-item").forEach((el) => {
          el.addEventListener("click", (e) => {
            if (e.target.closest(".delete")) return;
            urlInput.value = decodeURIComponent(el.dataset.url);
            urlInput.dispatchEvent(new Event("input"));
          });
        });
        historyList.querySelectorAll(".delete").forEach((el) => {
          el.addEventListener("click", (e) => {
            e.stopPropagation();
            const history = getHistory();
            history.splice(parseInt(el.dataset.idx), 1);
            saveHistory(history);
            renderHistory();
          });
        });
      }
      $("clearHistory").addEventListener("click", () => { saveHistory([]); renderHistory(); });
      renderHistory();

      // TV count polling
      async function updateTvCount() {
        try {
          const r = await fetch("/tv/clients");
          const d = await r.json();
          tvCount.textContent = d.clients || 0;
          tvCount.classList.toggle("zero", d.clients === 0);
        } catch {}
      }
      setInterval(updateTvCount, 3000);
      updateTvCount();

      // URL detection
      let detectTimeout = null;
      let currentDetection = null;

      urlInput.addEventListener("input", () => {
        const url = urlInput.value.trim();
        clearTimeout(detectTimeout);

        if (!url) {
          sendBtn.disabled = true;
          detectHint.classList.remove("ready");
          detectText.textContent = "Paste URL to detect type";
          inputIcon.setAttribute("data-lucide", "link");
          lucide.createIcons();
          updatePreview(null);
          return;
        }

        sendBtn.disabled = false;
        detectText.textContent = "Detecting...";

        detectTimeout = setTimeout(async () => {
          try {
            const r = await fetch(`/api/detect?url=${encodeURIComponent(url)}`);
            const d = await r.json();
            currentDetection = d;

            inputIcon.setAttribute("data-lucide", d.icon || "link");
            lucide.createIcons();

            detectHint.classList.add("ready");
            let text = "";
            if (d.site) text = `<span class="site-badge">${d.site}</span> `;
            if (d.title) text += d.title;
            else if (d.type === "torrent") text += "Torrent stream";
            else if (d.type === "video") text += "Direct video";
            else if (d.type === "stream") text += "HLS stream";
            else if (d.type === "youtube") text += "YouTube video";
            else text += "Website";

            detectText.innerHTML = text;
            updatePreview(url, d);
          } catch (e) {
            detectText.textContent = "Unknown URL type";
            currentDetection = { type: "website", method: "iframe" };
          }
        }, 300);
      });

      function updatePreview(url, detection) {
        if (!url) {
          preview.innerHTML = '<div class="preview-placeholder"><i data-lucide="film"></i><span>No media</span></div>';
          lucide.createIcons();
          return;
        }

        const lower = url.toLowerCase();

        if (detection?.thumbnail) {
          preview.innerHTML = `<img src="${detection.thumbnail}" alt="thumbnail">`;
        } else if (lower.endsWith(".mp4") || lower.endsWith(".webm")) {
          preview.innerHTML = `<video src="${url}" controls muted></video>`;
        } else if (/youtube|youtu\.be/.test(lower)) {
          const id = url.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/)?.[1];
          if (id) preview.innerHTML = `<iframe src="https://www.youtube.com/embed/${id}" allowfullscreen></iframe>`;
        } else if (detection?.type === "torrent") {
          preview.innerHTML = '<div class="preview-placeholder"><i data-lucide="download"></i><span>Torrent</span></div>';
          lucide.createIcons();
        } else {
          preview.innerHTML = '<div class="preview-placeholder"><i data-lucide="globe"></i><span>Website</span></div>';
          lucide.createIcons();
        }
      }

      // Send to TV
      sendBtn.addEventListener("click", sendToTv);
      urlInput.addEventListener("keypress", (e) => { if (e.key === "Enter") sendToTv(); });

      async function sendToTv() {
        const url = urlInput.value.trim();
        if (!url) return;

        status.className = "status";
        status.textContent = "Processing...";

        try {
          let urlToSend = url;
          let title = currentDetection?.title || url;
          let site = currentDetection?.site || "";
          let icon = currentDetection?.icon || "link";
          let episodes = null;
          let streamId = null;

          if (currentDetection?.method === "yt-dlp") {
            status.textContent = "Creating stream via yt-dlp...";
            const r = await fetch("/api/url2hls", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ url }),
            });
            const d = await r.json();
            if (d.error) throw new Error(d.error);
            urlToSend = d.streamUrl;
            title = d.name || title;
          }

          if (currentDetection?.type === "torrent" || url.startsWith("magnet:") || url.toLowerCase().endsWith(".torrent")) {
            status.textContent = "Creating torrent stream...";
            const r = await fetch("/api/torrent2mp4", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ url }),
            });
            const d = await r.json();
            if (d.error) throw new Error(d.error);
            urlToSend = d.streamUrl || `/hls/${encodeURIComponent(d.streamId)}.m3u8`;
            title = d.name || title;
            icon = "download";

            if (d.videoFiles && d.videoFiles.length > 1) {
              episodes = d.videoFiles;
              streamId = d.streamId;
              currentEpisodes = episodes;
              currentStreamId = streamId;
              currentMagnetURI = url;
              currentEpisodeIndex = 0;
              renderEpisodes();
            }
          }

          status.textContent = "Sending to TV...";
          const pushPayload = { url: urlToSend, name: title };
          if (episodes) {
            pushPayload.episodes = episodes;
            pushPayload.streamId = streamId;
            pushPayload.currentIndex = 0;
            pushPayload.magnetURI = url;
          }

          const pushRes = await fetch("/tv/push", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(pushPayload),
          });
          const pushData = await pushRes.json();

          if (pushData.success) {
            status.className = "status success";
            status.textContent = `Sent to ${pushData.clients} TV(s): ${title}`;
            addToHistory(url, title, site, icon);
          } else {
            throw new Error(pushData.error || "Failed to send");
          }
        } catch (e) {
          status.className = "status error";
          status.textContent = "Error: " + e.message;
        }
      }

      // Render episodes
      function renderEpisodes() {
        if (!currentEpisodes || currentEpisodes.length <= 1) {
          episodeSection.classList.remove("active");
          return;
        }

        episodeSection.classList.add("active");
        episodeCount.textContent = `${currentEpisodes.length} episodes`;

        episodeGrid.innerHTML = currentEpisodes.map((ep, i) => {
          const name = ep.name.replace(/\.(mp4|mkv|avi|webm)$/i, "");
          const sizeMB = (ep.length / 1024 / 1024).toFixed(0);
          return `
            <button class="episode-btn ${i === currentEpisodeIndex ? 'active' : ''}" data-index="${ep.index}">
              <div class="episode-btn-title">${name}</div>
              <div class="episode-btn-meta">${sizeMB} MB</div>
            </button>
          `;
        }).join("");

        episodeGrid.querySelectorAll(".episode-btn").forEach((btn) => {
          btn.addEventListener("click", () => switchEpisode(parseInt(btn.dataset.index)));
        });
      }

      // Switch episode
      async function switchEpisode(fileIndex) {
        if (!currentMagnetURI) return;

        status.className = "status";
        status.textContent = "Switching episode...";

        try {
          const infoHash = currentStreamId.split("_")[1];
          const r = await fetch("/api/torrent2mp4", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url: `magnet:?xt=urn:btih:${infoHash}`, fileIndex }),
          });
          const d = await r.json();
          if (d.error) throw new Error(d.error);

          const urlToSend = d.streamUrl || `/hls/${encodeURIComponent(d.streamId)}.m3u8`;
          currentEpisodeIndex = currentEpisodes.findIndex(ep => ep.index === fileIndex);
          currentStreamId = d.streamId;

          // Update active state
          episodeGrid.querySelectorAll(".episode-btn").forEach((btn, i) => {
            btn.classList.toggle("active", parseInt(btn.dataset.index) === fileIndex);
          });

          const pushRes = await fetch("/tv/push", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              url: urlToSend,
              name: d.name,
              episodes: currentEpisodes,
              streamId: d.streamId,
              currentIndex: currentEpisodeIndex,
              magnetURI: currentMagnetURI,
            }),
          });
          const pushData = await pushRes.json();

          if (pushData.success) {
            status.className = "status success";
            status.textContent = `Switched to: ${d.name}`;
          } else {
            throw new Error(pushData.error);
          }
        } catch (e) {
          status.className = "status error";
          status.textContent = "Error: " + e.message;
        }
      }

      // Secondary actions
      $("playHereBtn").addEventListener("click", () => {
        const url = urlInput.value.trim();
        if (url) location.href = `/player.html?url=${encodeURIComponent(url)}`;
      });

      $("copyLinkBtn").addEventListener("click", async () => {
        const url = urlInput.value.trim();
        if (!url) return;
        const shareUrl = `${location.origin}/player.html?url=${encodeURIComponent(url)}`;
        await navigator.clipboard.writeText(shareUrl);
        status.textContent = "Link copied!";
      });

      $("clearTvBtn").addEventListener("click", async () => {
        await fetch("/tv/clear", { method: "POST" });
        status.textContent = "TV cleared";
        currentEpisodes = null;
        currentStreamId = null;
        episodeSection.classList.remove("active");
      });

      // Remote control
      async function sendTvControl(action, value) {
        try {
          await fetch("/tv/control", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action, value }),
          });
        } catch (err) {
          console.error("Remote control error:", err);
        }
      }

      $("remoteBack30").addEventListener("click", () => sendTvControl("seekRelative", -30));
      $("remoteBack10").addEventListener("click", () => sendTvControl("seekRelative", -10));
      $("remotePlayPause").addEventListener("click", () => sendTvControl("togglePlay"));
      $("remoteForward10").addEventListener("click", () => sendTvControl("seekRelative", 10));
      $("remoteForward30").addEventListener("click", () => sendTvControl("seekRelative", 30));

      // Seek bar
      const remoteSeek = $("remoteSeek");
      const remoteSeekFill = $("remoteSeekFill");
      const remoteCurrentTime = $("remoteCurrentTime");
      const remoteDuration = $("remoteDuration");
      const remoteMedia = $("remoteMedia");
      const remotePlayIcon = $("remotePlayIcon");

      let currentDuration = 0;
      let isDragging = false;

      function handleSeek(e) {
        if (!currentDuration) return;
        const rect = remoteSeek.getBoundingClientRect();
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const pct = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
        const seekTime = pct * currentDuration;
        remoteSeekFill.style.width = (pct * 100) + "%";
        return seekTime;
      }

      remoteSeek.addEventListener("mousedown", (e) => {
        isDragging = true;
        const seekTime = handleSeek(e);
        sendTvControl("seek", seekTime);
      });

      remoteSeek.addEventListener("touchstart", (e) => {
        isDragging = true;
        handleSeek(e);
      }, { passive: true });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) handleSeek(e);
      });

      document.addEventListener("touchmove", (e) => {
        if (isDragging) handleSeek(e);
      }, { passive: true });

      document.addEventListener("mouseup", (e) => {
        if (isDragging) {
          isDragging = false;
          const seekTime = handleSeek(e);
          sendTvControl("seek", seekTime);
        }
      });

      document.addEventListener("touchend", (e) => {
        if (isDragging) {
          isDragging = false;
          sendTvControl("seek", handleSeek({ clientX: e.changedTouches[0].clientX }));
        }
      });

      // Swipe gesture for seeking
      const swipeZone = $("swipeZone");
      const swipeFeedback = $("swipeFeedback");
      const swipeIndicatorLeft = $("swipeIndicatorLeft");
      const swipeIndicatorRight = $("swipeIndicatorRight");

      let swipeStartX = 0;
      let swipeStartTime = 0;
      let isSwiping = false;
      let swipeSeekAmount = 0;

      // Sensitivity: pixels per second of seek
      const SWIPE_SENSITIVITY = 0.5; // 1px = 0.5 seconds
      const MIN_SWIPE_DISTANCE = 10;

      swipeZone.addEventListener("touchstart", (e) => {
        swipeStartX = e.touches[0].clientX;
        swipeStartTime = Date.now();
        isSwiping = true;
        swipeSeekAmount = 0;
        swipeZone.classList.add("swiping");
      }, { passive: true });

      swipeZone.addEventListener("touchmove", (e) => {
        if (!isSwiping) return;

        const deltaX = e.touches[0].clientX - swipeStartX;

        if (Math.abs(deltaX) < MIN_SWIPE_DISTANCE) {
          swipeSeekAmount = 0;
          swipeFeedback.textContent = "0s";
          swipeIndicatorLeft.style.width = "0";
          swipeIndicatorRight.style.width = "0";
          return;
        }

        // Calculate seek amount based on swipe distance
        swipeSeekAmount = Math.round(deltaX * SWIPE_SENSITIVITY);

        // Update feedback
        const sign = swipeSeekAmount >= 0 ? "+" : "";
        swipeFeedback.textContent = `${sign}${swipeSeekAmount}s`;

        // Update visual indicators
        const indicatorWidth = Math.min(Math.abs(deltaX), swipeZone.offsetWidth / 2);
        if (deltaX < 0) {
          swipeIndicatorLeft.style.width = indicatorWidth + "px";
          swipeIndicatorRight.style.width = "0";
        } else {
          swipeIndicatorRight.style.width = indicatorWidth + "px";
          swipeIndicatorLeft.style.width = "0";
        }
      }, { passive: true });

      swipeZone.addEventListener("touchend", (e) => {
        if (!isSwiping) return;
        isSwiping = false;
        swipeZone.classList.remove("swiping");

        // Reset indicators
        swipeIndicatorLeft.style.width = "0";
        swipeIndicatorRight.style.width = "0";

        // Apply seek if significant
        if (Math.abs(swipeSeekAmount) >= 1) {
          sendTvControl("seekRelative", swipeSeekAmount);

          // Brief visual feedback
          swipeFeedback.style.opacity = "1";
          setTimeout(() => {
            swipeFeedback.style.opacity = "0";
          }, 500);
        }

        swipeSeekAmount = 0;
      });

      // Mouse support for desktop testing
      swipeZone.addEventListener("mousedown", (e) => {
        swipeStartX = e.clientX;
        isSwiping = true;
        swipeSeekAmount = 0;
        swipeZone.classList.add("swiping");
      });

      document.addEventListener("mousemove", (e) => {
        if (!isSwiping || !swipeZone.classList.contains("swiping")) return;

        const deltaX = e.clientX - swipeStartX;

        if (Math.abs(deltaX) < MIN_SWIPE_DISTANCE) {
          swipeSeekAmount = 0;
          swipeFeedback.textContent = "0s";
          swipeIndicatorLeft.style.width = "0";
          swipeIndicatorRight.style.width = "0";
          return;
        }

        swipeSeekAmount = Math.round(deltaX * SWIPE_SENSITIVITY);
        const sign = swipeSeekAmount >= 0 ? "+" : "";
        swipeFeedback.textContent = `${sign}${swipeSeekAmount}s`;

        const indicatorWidth = Math.min(Math.abs(deltaX), swipeZone.offsetWidth / 2);
        if (deltaX < 0) {
          swipeIndicatorLeft.style.width = indicatorWidth + "px";
          swipeIndicatorRight.style.width = "0";
        } else {
          swipeIndicatorRight.style.width = indicatorWidth + "px";
          swipeIndicatorLeft.style.width = "0";
        }
      });

      document.addEventListener("mouseup", (e) => {
        if (!isSwiping || !swipeZone.classList.contains("swiping")) return;
        isSwiping = false;
        swipeZone.classList.remove("swiping");

        swipeIndicatorLeft.style.width = "0";
        swipeIndicatorRight.style.width = "0";

        if (Math.abs(swipeSeekAmount) >= 1) {
          sendTvControl("seekRelative", swipeSeekAmount);
        }

        swipeSeekAmount = 0;
      });

      function formatTime(s) {
        if (!s || isNaN(s)) return "00:00";
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = Math.floor(s % 60);
        if (h > 0) return `${h}:${m.toString().padStart(2, "0")}:${sec.toString().padStart(2, "0")}`;
        return `${m.toString().padStart(2, "0")}:${sec.toString().padStart(2, "0")}`;
      }

      // SSE for remote state
      function connectRemoteSSE() {
        const evtSource = new EventSource("/tv/remote");

        evtSource.onmessage = (e) => {
          try {
            const state = JSON.parse(e.data);
            currentDuration = state.duration || 0;

            if (!isDragging) {
              remoteCurrentTime.textContent = formatTime(state.currentTime);
              remoteDuration.textContent = formatTime(state.duration);
              const pct = state.duration ? (state.currentTime / state.duration) * 100 : 0;
              remoteSeekFill.style.width = pct + "%";
            }

            remoteMedia.textContent = state.mediaName || "Nothing playing";
            remotePlayIcon.setAttribute("data-lucide", state.paused ? "play" : "pause");
            lucide.createIcons();

            // Update episodes from TV state
            if (state.episodes && state.episodes.length > 1) {
              if (!currentEpisodes || JSON.stringify(currentEpisodes) !== JSON.stringify(state.episodes)) {
                currentEpisodes = state.episodes;
                currentStreamId = state.streamId;
                currentMagnetURI = state.magnetURI;
                currentEpisodeIndex = state.currentIndex || 0;
                renderEpisodes();
              }
              // Update active episode
              if (state.currentIndex !== undefined && state.currentIndex !== currentEpisodeIndex) {
                currentEpisodeIndex = state.currentIndex;
                episodeGrid.querySelectorAll(".episode-btn").forEach((btn) => {
                  const idx = currentEpisodes.findIndex(ep => ep.index === parseInt(btn.dataset.index));
                  btn.classList.toggle("active", idx === currentEpisodeIndex);
                });
              }
            }
          } catch (err) {
            console.error("Remote SSE error:", err);
          }
        };

        evtSource.onerror = () => {
          evtSource.close();
          setTimeout(connectRemoteSSE, 3000);
        };
      }

      connectRemoteSSE();

      // Search
      let currentSearchSource = "youtube";
      let searchTimeout = null;

      $("searchBtn").addEventListener("click", () => {
        searchModal.classList.add("active");
        searchInput.focus();
      });

      $("closeSearch").addEventListener("click", () => searchModal.classList.remove("active"));

      searchModal.addEventListener("click", (e) => {
        if (e.target === searchModal || e.target.classList.contains("modal-content") === false && e.target.closest(".modal-content") === null) {
          searchModal.classList.remove("active");
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && searchModal.classList.contains("active")) {
          searchModal.classList.remove("active");
        }
      });

      document.querySelectorAll(".modal-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".modal-tab").forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          currentSearchSource = tab.dataset.source;
          if (searchInput.value.trim()) performSearch(searchInput.value.trim());
        });
      });

      searchInput.addEventListener("input", () => {
        const query = searchInput.value.trim();
        clearTimeout(searchTimeout);
        if (!query) {
          searchResultsContainer.innerHTML = '<div class="search-empty">Enter a search query</div>';
          return;
        }
        searchResultsContainer.innerHTML = '<div class="search-loading">Searching...</div>';
        searchTimeout = setTimeout(() => performSearch(query), 500);
      });

      searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          clearTimeout(searchTimeout);
          const query = searchInput.value.trim();
          if (query) performSearch(query);
        }
      });

      async function performSearch(query) {
        try {
          const endpoint = currentSearchSource === "youtube"
            ? `/api/search/youtube?q=${encodeURIComponent(query)}`
            : `/api/search/torrents?q=${encodeURIComponent(query)}`;

          const response = await fetch(endpoint);
          const data = await response.json();

          if (data.error) {
            searchResultsContainer.innerHTML = `<div class="search-empty">Error: ${data.error}</div>`;
            return;
          }

          if (!data.results || data.results.length === 0) {
            searchResultsContainer.innerHTML = '<div class="search-empty">No results found</div>';
            return;
          }

          renderSearchResults(data.results);
        } catch (err) {
          searchResultsContainer.innerHTML = `<div class="search-empty">Search error: ${err.message}</div>`;
        }
      }

      function renderSearchResults(results) {
        const html = results.map((r) => {
          let meta = "";
          if (currentSearchSource === "youtube") {
            const duration = r.duration ? formatDuration(r.duration) : "";
            const views = r.views ? formatViews(r.views) : "";
            meta = [r.channel, views, duration].filter(Boolean).join("  ");
          } else {
            const parts = [];
            if (r.size) parts.push(r.size);
            if (r.seeders !== undefined) parts.push(`${r.seeders} seeds`);
            meta = parts.join("  ");
          }

          const url = r.url || r.magnetLink || "";
          const isTorrent = currentSearchSource === "torrents" && url.startsWith("magnet:");
          const thumbContent = r.thumbnail
            ? `<img src="${r.thumbnail}" alt="">`
            : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:var(--gray-600);font-size:24px;"></div>';

          return `
            <div class="search-result" data-url="${encodeURIComponent(url)}" data-title="${encodeURIComponent(r.title)}" data-is-torrent="${isTorrent}">
              <div class="search-result-thumb">${thumbContent}</div>
              <div class="search-result-info">
                <div class="search-result-title">${escapeHtml(r.title)}</div>
                ${meta ? `<div class="search-result-meta">${meta}</div>` : ""}
              </div>
              ${isTorrent ? `<button class="torrent-picker-btn" title="Select files"><i data-lucide="folder-open"></i></button>` : ""}
            </div>
          `;
        }).join("");

        searchResultsContainer.innerHTML = `<div class="search-results">${html}</div>`;
        lucide.createIcons();

        searchResultsContainer.querySelectorAll(".search-result").forEach((el) => {
          const pickerBtn = el.querySelector(".torrent-picker-btn");
          const isTorrent = el.dataset.isTorrent === "true";

          // Picker button click - open file picker
          if (pickerBtn) {
            pickerBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              const url = decodeURIComponent(el.dataset.url);
              const title = decodeURIComponent(el.dataset.title);
              openTorrentPicker(url, title);
            });
          }

          // Main click - for torrents: open picker, for youtube: set URL
          el.addEventListener("click", (e) => {
            if (e.target.closest(".torrent-picker-btn")) return;
            const url = decodeURIComponent(el.dataset.url);

            if (isTorrent) {
              // For torrents, open the file picker
              const title = decodeURIComponent(el.dataset.title);
              openTorrentPicker(url, title);
            } else {
              // For YouTube, set URL directly
              urlInput.value = url;
              urlInput.dispatchEvent(new Event("input"));
              searchModal.classList.remove("active");
            }
          });
        });
      }

      function formatDuration(seconds) {
        if (!seconds) return "";
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        if (h > 0) return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
        return `${m}:${String(s).padStart(2, "0")}`;
      }

      function formatViews(views) {
        if (!views) return "";
        if (views >= 1000000) return `${(views / 1000000).toFixed(1)}M`;
        if (views >= 1000) return `${(views / 1000).toFixed(0)}K`;
        return `${views}`;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Drag & drop
      document.addEventListener("dragenter", (e) => {
        e.preventDefault();
        if (e.dataTransfer.types.includes("Files")) dropZone.classList.add("active");
      });
      dropZone.addEventListener("dragleave", (e) => {
        if (e.target === dropZone) dropZone.classList.remove("active");
      });
      dropZone.addEventListener("dragover", (e) => e.preventDefault());
      dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        dropZone.classList.remove("active");
        const file = e.dataTransfer.files[0];
        if (!file || !file.name.endsWith(".torrent")) {
          status.textContent = "Only .torrent files supported";
          return;
        }
        status.textContent = `Torrent: ${file.name} - Please use magnet link`;
      });

      // ============== PWA FEATURES ==============

      // Install prompt
      let deferredPrompt = null;
      const installBanner = document.createElement('div');
      installBanner.className = 'install-banner';
      installBanner.innerHTML = `
        <div class="install-content">
          <i data-lucide="download"></i>
          <div class="install-text">
            <strong>Install LAN Video</strong>
            <span>Add to home screen for the best experience</span>
          </div>
        </div>
        <div class="install-actions">
          <button class="install-btn" id="installBtn">Install</button>
          <button class="install-dismiss" id="dismissInstall"><i data-lucide="x"></i></button>
        </div>
      `;

      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;

        // Show install banner if not dismissed before
        if (!localStorage.getItem('pwa-install-dismissed')) {
          document.body.appendChild(installBanner);
          lucide.createIcons();

          document.getElementById('installBtn').addEventListener('click', async () => {
            if (!deferredPrompt) return;
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            console.log('Install outcome:', outcome);
            deferredPrompt = null;
            installBanner.remove();
          });

          document.getElementById('dismissInstall').addEventListener('click', () => {
            localStorage.setItem('pwa-install-dismissed', Date.now());
            installBanner.remove();
          });
        }
      });

      window.addEventListener('appinstalled', () => {
        console.log('PWA installed');
        installBanner.remove();
        deferredPrompt = null;
      });

      // Offline indicator
      const offlineIndicator = document.createElement('div');
      offlineIndicator.className = 'offline-indicator';
      offlineIndicator.innerHTML = '<i data-lucide="wifi-off"></i> Offline';

      function updateOnlineStatus() {
        if (!navigator.onLine) {
          document.body.appendChild(offlineIndicator);
          lucide.createIcons();
          sendBtn.disabled = true;
        } else {
          offlineIndicator.remove();
          sendBtn.disabled = !urlInput.value.trim();
        }
      }

      window.addEventListener('online', updateOnlineStatus);
      window.addEventListener('offline', updateOnlineStatus);
      updateOnlineStatus();

      // Badge API for TV count
      async function updateBadge(count) {
        if ('setAppBadge' in navigator) {
          try {
            if (count > 0) {
              await navigator.setAppBadge(count);
            } else {
              await navigator.clearAppBadge();
            }
          } catch (e) {
            console.log('Badge API error:', e);
          }
        }
      }

      // Update badge when TV count changes
      const originalUpdateTvCount = updateTvCount;
      updateTvCount = async function() {
        try {
          const r = await fetch("/tv/clients");
          const d = await r.json();
          tvCount.textContent = d.clients || 0;
          tvCount.classList.toggle("zero", d.clients === 0);
          updateBadge(d.clients || 0);
        } catch {}
      };

      // Handle shared URLs (Web Share Target API)
      const urlParams = new URLSearchParams(window.location.search);
      const sharedUrl = urlParams.get('shared') || urlParams.get('url') || urlParams.get('text');
      const sharedMagnet = urlParams.get('magnet');
      const sharedVideo = urlParams.get('video');

      if (sharedUrl || sharedMagnet || sharedVideo) {
        const urlToUse = sharedUrl || sharedMagnet || sharedVideo;
        urlInput.value = decodeURIComponent(urlToUse);
        urlInput.dispatchEvent(new Event('input'));
        // Clean URL
        window.history.replaceState({}, '', '/');
      }

      // Handle action shortcuts
      const action = urlParams.get('action');
      if (action === 'search') {
        setTimeout(() => {
          searchModal.classList.add('active');
          searchInput.focus();
        }, 500);
      } else if (action === 'remote') {
        setTimeout(() => {
          document.getElementById('remoteControl').scrollIntoView({ behavior: 'smooth' });
        }, 500);
      }

      // Push notification subscription
      async function subscribeToPush() {
        if (!('PushManager' in window)) return null;

        try {
          const registration = await navigator.serviceWorker.ready;
          let subscription = await registration.pushManager.getSubscription();

          if (!subscription) {
            // Get VAPID public key from server
            const response = await fetch('/api/push/vapid-public-key');
            if (!response.ok) return null;

            const { publicKey } = await response.json();
            const convertedKey = urlBase64ToUint8Array(publicKey);

            subscription = await registration.pushManager.subscribe({
              userVisibleOnly: true,
              applicationServerKey: convertedKey
            });

            // Send subscription to server
            await fetch('/api/push/subscribe', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(subscription)
            });
          }

          return subscription;
        } catch (e) {
          console.log('Push subscription error:', e);
          return null;
        }
      }

      function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }

      // Request notification permission on first interaction
      let notificationRequested = false;
      document.addEventListener('click', async () => {
        if (notificationRequested) return;
        notificationRequested = true;

        if ('Notification' in window && Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            subscribeToPush();
          }
        }
      }, { once: true });

      // Service Worker registration with update handling
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
          .then((reg) => {
            console.log('SW registered:', reg.scope);

            // Check for updates
            reg.addEventListener('updatefound', () => {
              const newWorker = reg.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version available
                  showUpdateNotification();
                }
              });
            });
          })
          .catch((err) => console.log('SW registration failed:', err));

        // Handle SW messages
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data.type === 'notification-click') {
            // Handle notification click data
            console.log('Notification clicked:', event.data);
          }
        });
      }

      function showUpdateNotification() {
        const updateBanner = document.createElement('div');
        updateBanner.className = 'update-banner';
        updateBanner.innerHTML = `
          <span>New version available!</span>
          <button onclick="location.reload()">Update</button>
        `;
        document.body.appendChild(updateBanner);
      }

      // Background sync for offline sends
      async function queueForSync(payload) {
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
          const reg = await navigator.serviceWorker.ready;

          // Store request in SW
          navigator.serviceWorker.controller?.postMessage({
            type: 'QUEUE_REQUEST',
            payload
          });

          await reg.sync.register('send-to-tv');
          return true;
        }
        return false;
      }

      // Periodic background sync for TV status
      async function registerPeriodicSync() {
        if ('serviceWorker' in navigator && 'periodicSync' in ServiceWorkerRegistration.prototype) {
          try {
            const reg = await navigator.serviceWorker.ready;
            const status = await navigator.permissions.query({ name: 'periodic-background-sync' });

            if (status.state === 'granted') {
              await reg.periodicSync.register('update-tv-status', {
                minInterval: 60 * 1000 // 1 minute
              });
              console.log('Periodic sync registered');
            }
          } catch (e) {
            console.log('Periodic sync not available:', e);
          }
        }
      }

      registerPeriodicSync();

      // ============== AI MEDIA ASSISTANT ==============
      let mediaAI = null;

      async function initAI() {
        try {
          await mediaDB.ready;
          mediaAI = new MediaAI(mediaDB);
          mediaAI.startNetworkMonitoring();

          // Update dashboard
          updateAIDashboard();

          // Update every 30 seconds
          setInterval(updateAIDashboard, 30000);
        } catch (e) {
          console.error('AI init failed:', e);
        }
      }

      async function updateAIDashboard() {
        if (!mediaAI) return;

        // Update network status
        const netStats = await mediaDB.getAverageSpeed();
        const networkQuality = $('networkQuality');
        const networkDetail = $('networkDetail');

        if (netStats) {
          networkQuality.textContent = `Recommended: ${netStats.quality}`;
          networkDetail.textContent = `${netStats.recommendedBitrate} Mbps`;
        } else {
          networkQuality.textContent = 'Measuring...';
        }

        // Update storage
        try {
          const storageResp = await fetch('/api/storage/stats');
          const storage = await storageResp.json();
          $('storageUsed').textContent = storage.formatted.total;
        } catch (e) {
          $('storageUsed').textContent = 'N/A';
        }

        // Update continue watching
        const continueList = await mediaAI.getContinueWatching();
        const continueSection = $('continueSection');
        const continueListEl = $('continueList');

        if (continueList.length > 0) {
          continueSection.style.display = 'block';
          continueListEl.innerHTML = continueList.slice(0, 5).map(item => {
            if (item.type === 'series') {
              return `
                <div class="ai-continue-item" data-infohash="${item.infoHash}" data-episode="${item.nextEpisode}">
                  <div class="ai-continue-thumb">
                    <i data-lucide="tv"></i>
                    <div class="ai-continue-progress" style="width:${item.progress}%"></div>
                  </div>
                  <div class="ai-continue-info">
                    <div class="ai-continue-title">${item.title}</div>
                    <div class="ai-continue-meta">Episode ${item.nextEpisode + 1} of ${item.totalCount}</div>
                  </div>
                </div>
              `;
            } else {
              return `
                <div class="ai-continue-item" data-id="${item.id}">
                  <div class="ai-continue-thumb">
                    <i data-lucide="play"></i>
                    <div class="ai-continue-progress" style="width:${item.progress}%"></div>
                  </div>
                  <div class="ai-continue-info">
                    <div class="ai-continue-title">${item.title || 'Video'}</div>
                    <div class="ai-continue-meta">${item.progress}% watched</div>
                  </div>
                </div>
              `;
            }
          }).join('');
          lucide.createIcons();
        } else {
          continueSection.style.display = 'none';
        }

        // Check cleanup suggestions
        const cleanupSuggestions = await mediaAI.getCleanupSuggestions();
        const cleanupBtn = $('cleanupBtn');
        const cleanupSize = $('cleanupSize');

        if (cleanupSuggestions.length > 0) {
          const totalSize = cleanupSuggestions.reduce((sum, s) => sum + (s.size || 0), 0);
          cleanupBtn.style.display = 'flex';
          cleanupSize.textContent = formatBytes(totalSize);

          cleanupBtn.onclick = async () => {
            if (confirm(`Delete ${cleanupSuggestions.length} watched episodes (${formatBytes(totalSize)})?`)) {
              status.textContent = 'Cleaning up...';
              const results = await mediaAI.performCleanup(cleanupSuggestions);
              const deleted = results.filter(r => r.status === 'deleted').length;
              status.textContent = `Deleted ${deleted} files`;
              updateAIDashboard();
            }
          };
        } else {
          cleanupBtn.style.display = 'none';
        }
      }

      function formatBytes(bytes) {
        if (bytes >= 1024 * 1024 * 1024) return (bytes / 1024 / 1024 / 1024).toFixed(1) + ' GB';
        if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(0) + ' MB';
        return (bytes / 1024).toFixed(0) + ' KB';
      }

      // Enhanced search with AI filtering
      const originalPerformSearch = performSearch;
      performSearch = async function(query) {
        if (currentSearchSource === 'torrents' && mediaAI) {
          try {
            searchResultsContainer.innerHTML = '<div class="search-loading">AI filtering results...</div>';
            const results = await mediaAI.smartSearch(query);
            renderSearchResultsWithAI(results);
            return;
          } catch (e) {
            console.error('AI search failed, falling back:', e);
          }
        }
        return originalPerformSearch(query);
      };

      function renderSearchResultsWithAI(results) {
        if (!results || results.length === 0) {
          searchResultsContainer.innerHTML = '<div class="search-empty">No results found (or all have too few seeders)</div>';
          return;
        }

        const html = results.map((r, idx) => {
          const qualityBadge = r.aiQuality ?
            `<span class="ai-quality-badge" style="background:${r.aiSuitable ? '#22c55e' : '#f97316'}">${r.aiQuality}</span>` : '';

          const healthBadge = r.aiHealth ?
            `<span class="ai-health-badge" style="background:${r.aiHealth.color}">${r.seeders} seeds</span>` : '';

          // Show if has better quality available for smart streaming
          const smartBadge = r.hasAlternatives && r.smartStreamUseful ?
            `<span class="ai-smart-badge">+${r.bestQuality}</span>` : '';

          const meta = [r.size].filter(Boolean).join('  ');
          const url = r.magnetLink || '';
          const title = r.name || r.title || '';

          return `
            <div class="search-result ${r.hasAlternatives ? 'has-alternatives' : ''}"
                 data-url="${encodeURIComponent(url)}"
                 data-title="${encodeURIComponent(title)}"
                 data-idx="${idx}">
              <div class="search-result-thumb">
                <div style="width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;">
                  ${qualityBadge}
                  ${healthBadge}
                  ${smartBadge}
                </div>
              </div>
              <div class="search-result-info">
                <div class="search-result-title">${escapeHtml(title)}</div>
                <div class="search-result-meta">${meta}${r.hasAlternatives ? `  ${r.alternativeCount + 1} versions` : ''}${!r.aiSuitable ? '  May buffer' : ''}</div>
              </div>
              <button class="torrent-picker-btn" title="Select files"><i data-lucide="folder-open"></i></button>
            </div>
          `;
        }).join('');

        searchResultsContainer.innerHTML = `<div class="search-results">${html}</div>`;
        lucide.createIcons();
        window._aiSearchResults = results;

        searchResultsContainer.querySelectorAll('.search-result').forEach((el) => {
          const pickerBtn = el.querySelector('.torrent-picker-btn');

          // Picker button - open file picker
          if (pickerBtn) {
            pickerBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const url = decodeURIComponent(el.dataset.url);
              const title = decodeURIComponent(el.dataset.title);
              openTorrentPicker(url, title);
            });
          }

          // Main click - open file picker for torrents
          el.addEventListener('click', async (e) => {
            if (e.target.closest('.torrent-picker-btn')) return;

            const url = decodeURIComponent(el.dataset.url);
            const title = decodeURIComponent(el.dataset.title);
            openTorrentPicker(url, title);
          });
        });
      }

      // Track watch history
      const originalSendToTv = sendToTv;
      sendToTv = async function() {
        await originalSendToTv();

        // Add to IndexedDB history
        if (mediaDB && currentDetection) {
          mediaDB.addToHistory({
            url: urlInput.value,
            title: currentDetection.title,
            type: currentDetection.type,
            thumbnail: currentDetection.thumbnail
          });
        }
      };

      // ============== DOWNLOAD MANAGER ==============
      const downloadManagerModal = $("downloadManagerModal");
      const downloadManagerBody = $("downloadManagerBody");
      const downloadsBadge = $("downloadsBadge");
      let downloadUpdateInterval = null;

      $("downloadsBtn").addEventListener("click", () => {
        downloadManagerModal.classList.add("active");
        updateDownloadManager();
        // Start polling for updates
        if (!downloadUpdateInterval) {
          downloadUpdateInterval = setInterval(updateDownloadManager, 2000);
        }
      });

      $("closeDownloadManager").addEventListener("click", () => {
        downloadManagerModal.classList.remove("active");
        if (downloadUpdateInterval) {
          clearInterval(downloadUpdateInterval);
          downloadUpdateInterval = null;
        }
      });

      downloadManagerModal.addEventListener("click", (e) => {
        if (e.target === downloadManagerModal) {
          downloadManagerModal.classList.remove("active");
          if (downloadUpdateInterval) {
            clearInterval(downloadUpdateInterval);
            downloadUpdateInterval = null;
          }
        }
      });

      function formatSpeed(bytesPerSec) {
        if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + " B/s";
        if (bytesPerSec < 1024 * 1024) return (bytesPerSec / 1024).toFixed(1) + " KB/s";
        return (bytesPerSec / (1024 * 1024)).toFixed(2) + " MB/s";
      }

      function formatBytes(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
        if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + " MB";
        return (bytes / (1024 * 1024 * 1024)).toFixed(2) + " GB";
      }

      async function updateDownloadManager() {
        try {
          const res = await fetch("/api/downloads/status");
          const downloads = await res.json();

          // Update badge
          const activeCount = downloads.length;
          if (activeCount > 0) {
            downloadsBadge.textContent = activeCount;
            downloadsBadge.style.display = "flex";
          } else {
            downloadsBadge.style.display = "none";
          }

          if (downloads.length === 0) {
            downloadManagerBody.innerHTML = '<div class="downloads-empty">No active downloads</div>';
            return;
          }

          const html = downloads.map(dl => {
            const filesHtml = dl.files.map((f, fileIdx) => {
              const progress = Math.min(100, f.progress || 0);
              const canPlay = progress >= 5; // Can play if at least 5% downloaded
              return `
                <div class="download-item" data-infohash="${dl.infoHash}" data-file-idx="${fileIdx}">
                  <div class="download-item-header">
                    <div class="download-item-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</div>
                    <div class="download-item-controls">
                      ${canPlay ? `<button class="download-ctrl-btn play" onclick="playDownload('${dl.infoHash}', ${fileIdx})" title="Play">
                        <i data-lucide="play"></i>
                      </button>` : ''}
                      <button class="download-ctrl-btn danger" onclick="stopDownload('${dl.infoHash}')" title="Stop">
                        <i data-lucide="x"></i>
                      </button>
                    </div>
                  </div>
                  <div class="download-item-progress">
                    <div class="download-item-progress-fill" style="width: ${progress}%"></div>
                  </div>
                  <div class="download-item-meta">
                    <span>${formatBytes(f.downloaded || 0)} / ${formatBytes(f.size)}</span>
                    <span class="download-item-speed">${formatSpeed(dl.downloadSpeed)} - ${dl.peers} peers</span>
                  </div>
                </div>
              `;
            }).join('');
            return filesHtml;
          }).join('');

          downloadManagerBody.innerHTML = `<div class="download-list">${html}</div>`;
          lucide.createIcons();
        } catch (err) {
          console.error("Failed to update download manager:", err);
        }
      }

      window.stopDownload = async function(infoHash) {
        if (!confirm("Stop this download?")) return;
        try {
          await fetch(`/api/torrent/stop/${infoHash}`, { method: "POST" });
          updateDownloadManager();
        } catch (err) {
          console.error("Failed to stop download:", err);
        }
      };

      window.playDownload = async function(infoHash, fileIdx) {
        try {
          // Get stream URL for this torrent file
          const res = await fetch("/api/torrent/play", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ infoHash, fileIndex: fileIdx })
          });
          const data = await res.json();

          if (data.streamUrl) {
            downloadManagerModal.classList.remove("active");
            urlInput.value = data.streamUrl;
            urlInput.dispatchEvent(new Event("input"));
            // Auto-send to TV
            setTimeout(() => sendToTv(), 500);
          } else {
            alert("Error: " + (data.error || "Could not start playback"));
          }
        } catch (err) {
          console.error("Failed to play download:", err);
          alert("Failed to play: " + err.message);
        }
      };

      // Downloads section on main page
      const downloadsSectionList = $("downloadsSectionList");
      const downloadsCount = $("downloadsCount");

      async function updateDownloadsSection() {
        try {
          const res = await fetch("/api/downloads/status");
          const downloads = await res.json();

          // Count total files
          let totalFiles = 0;
          downloads.forEach(dl => totalFiles += dl.files.length);

          // Update badge
          if (totalFiles > 0) {
            downloadsBadge.textContent = totalFiles;
            downloadsBadge.style.display = "flex";
            downloadsCount.textContent = totalFiles;
          } else {
            downloadsBadge.style.display = "none";
            downloadsCount.textContent = "0";
          }

          if (downloads.length === 0) {
            downloadsSectionList.innerHTML = '<div class="downloads-section-empty">No downloads</div>';
            return;
          }

          // Flatten all files
          const allFiles = [];
          downloads.forEach(dl => {
            dl.files.forEach((f, idx) => {
              allFiles.push({
                ...f,
                torrentName: dl.name,
                infoHash: dl.infoHash,
                fileIdx: idx,
                active: dl.active,
                completed: dl.completed,
                peers: dl.peers,
                speed: dl.downloadSpeed
              });
            });
          });

          const html = allFiles.map((f, i) => {
            const isDownloading = f.active && f.progress < 100;
            const canPlay = f.progress >= 5;
            return `
              <div class="dl-item" data-idx="${i}">
                <div class="dl-item-info">
                  <div class="dl-item-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</div>
                  <div class="dl-item-meta">
                    <span>${formatBytes(f.size)}</span>
                    ${isDownloading ? `<span>${formatSpeed(f.speed)}</span>` : ''}
                    ${f.progress === 100 ? '<span style="color:var(--success)">Complete</span>' : `<span>${f.progress}%</span>`}
                  </div>
                </div>
                <div class="dl-item-progress">
                  <div class="dl-item-progress-fill ${isDownloading ? 'downloading' : ''}" style="width:${f.progress}%"></div>
                </div>
                <div class="dl-item-actions">
                  ${canPlay ? `<button class="dl-item-btn play" data-play="${i}"><i data-lucide="play"></i></button>` : ''}
                </div>
              </div>
            `;
          }).join('');

          downloadsSectionList.innerHTML = html;
          lucide.createIcons();

          // Store files data for click handlers
          window._dlFiles = allFiles;

          // Add click handlers
          downloadsSectionList.querySelectorAll('.dl-item-btn.play').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.dataset.play);
              const file = window._dlFiles[idx];
              if (file) {
                playFileFromData(file);
              }
            });
          });
        } catch (e) {
          console.error("Failed to update downloads section:", e);
        }
      }

      // Play file from data object
      async function playFileFromData(file) {
        console.log("Playing file:", file);
        if (file.path) {
          // Local file - use local2hls
          try {
            const res = await fetch("/api/local2hls", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ filePath: file.path })
            });
            const data = await res.json();
            console.log("local2hls response:", data);
            if (data.hlsUrl) {
              urlInput.value = data.hlsUrl;
              urlInput.dispatchEvent(new Event("input"));
              setTimeout(() => sendToTv(), 500);
            } else {
              alert("Error: " + (data.error || "Failed to create stream"));
            }
          } catch (e) {
            alert("Failed to play: " + e.message);
          }
        } else {
          // Active torrent - use torrent/play
          playDownload(file.infoHash, file.fileIdx);
        }
      }

      // Update downloads section every 3 seconds
      updateDownloadsSection();
      setInterval(updateDownloadsSection, 3000);

      // ============== TORRENT FILE PICKER ==============
      const torrentPickerModal = $("torrentPickerModal");
      const torrentPickerBody = $("torrentPickerBody");
      const torrentPickerTitle = $("torrentPickerTitle");
      let currentTorrentMagnet = null;
      let currentTorrentFiles = [];

      $("closeTorrentPicker").addEventListener("click", () => {
        torrentPickerModal.classList.remove("active");
      });

      torrentPickerModal.addEventListener("click", (e) => {
        if (e.target === torrentPickerModal) {
          torrentPickerModal.classList.remove("active");
        }
      });

      $("torrentSelectAll").addEventListener("click", () => {
        const checkboxes = torrentPickerBody.querySelectorAll('input[type="checkbox"]');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        checkboxes.forEach(cb => {
          cb.checked = !allChecked;
          cb.closest('.torrent-file-item').classList.toggle('selected', !allChecked);
        });
      });

      $("torrentStartDownload").addEventListener("click", async () => {
        const checkboxes = torrentPickerBody.querySelectorAll('input[type="checkbox"]:checked');
        const fileIndexes = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));

        if (fileIndexes.length === 0) {
          alert("Select at least one file");
          return;
        }

        // Start download
        const res = await fetch("/api/torrent/download", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ magnet: currentTorrentMagnet, fileIndexes })
        });
        const data = await res.json();

        if (data.success) {
          torrentPickerModal.classList.remove("active");
          // If only one file, start playing it
          if (fileIndexes.length === 1) {
            const file = currentTorrentFiles.find(f => f.index === fileIndexes[0]);
            urlInput.value = currentTorrentMagnet;
            urlInput.dispatchEvent(new Event('input'));
          }
          alert(`Started downloading ${fileIndexes.length} file(s)`);
        } else {
          alert("Error: " + data.error);
        }
      });

      async function openTorrentPicker(magnet, title) {
        currentTorrentMagnet = magnet;
        torrentPickerTitle.textContent = title || "Select files";
        torrentPickerBody.innerHTML = '<div class="torrent-loading">Loading torrent info...</div>';
        torrentPickerModal.classList.add("active");

        try {
          const res = await fetch("/api/torrent/preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ magnet })
          });
          const data = await res.json();

          if (data.error) {
            torrentPickerBody.innerHTML = `<div class="torrent-loading">Error: ${data.error}</div>`;
            return;
          }

          currentTorrentFiles = data.files;
          torrentPickerTitle.textContent = data.name || title || "Select files";

          if (data.files.length === 0) {
            torrentPickerBody.innerHTML = '<div class="torrent-loading">No video files found</div>';
            return;
          }

          const html = data.files.map(f => `
            <div class="torrent-file-item" data-index="${f.index}">
              <input type="checkbox" data-index="${f.index}" />
              <div class="torrent-file-info">
                <div class="torrent-file-name">${escapeHtml(f.name)}</div>
                <div class="torrent-file-size">${f.sizeFormatted}</div>
              </div>
            </div>
          `).join('');

          torrentPickerBody.innerHTML = `<div class="torrent-file-list">${html}</div>`;

          // Click handlers
          torrentPickerBody.querySelectorAll('.torrent-file-item').forEach(item => {
            item.addEventListener('click', (e) => {
              if (e.target.tagName === 'INPUT') return;
              const cb = item.querySelector('input[type="checkbox"]');
              cb.checked = !cb.checked;
              item.classList.toggle('selected', cb.checked);
            });
          });

        } catch (err) {
          torrentPickerBody.innerHTML = `<div class="torrent-loading">Error: ${err.message}</div>`;
        }
      }

      // Init AI on load
      initAI();
    </script>

    <style>
      .install-banner {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--gray-900);
        border-top: 1px solid var(--gray-700);
        padding: 16px 20px;
        padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        z-index: 1000;
        animation: slideUp 0.3s ease;
      }
      @keyframes slideUp {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }
      .install-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .install-content i {
        width: 32px;
        height: 32px;
        color: var(--accent);
      }
      .install-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .install-text strong {
        font-size: 14px;
      }
      .install-text span {
        font-size: 12px;
        color: var(--gray-400);
      }
      .install-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .install-btn {
        padding: 8px 16px;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
      }
      .install-dismiss {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        color: var(--gray-500);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .install-dismiss i {
        width: 20px;
        height: 20px;
      }

      .offline-indicator {
        position: fixed;
        top: env(safe-area-inset-top, 0px);
        left: 0;
        right: 0;
        background: var(--accent);
        color: white;
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        z-index: 1001;
      }
      .offline-indicator i {
        width: 16px;
        height: 16px;
      }

      .update-banner {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--success);
        color: white;
        padding: 12px 20px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 14px;
        font-weight: 500;
        z-index: 1002;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
      .update-banner button {
        padding: 6px 12px;
        background: white;
        color: var(--success);
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
      }
    </style>
  </body>
</html>
